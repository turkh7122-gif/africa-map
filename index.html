<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>MILITANT Atlas-AFRICA</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Helvetica, sans-serif; background: #111; color: #eee; height: 100vh; overflow: hidden; touch-action: none; }
    #container { display: flex; height: 100%; }
    #map-area { flex: 1; position: relative; background: #1a1a1a; overflow: hidden; touch-action: none; cursor: grab; }
    svg { width: 100%; height: 100%; display: block; user-select: none; touch-action: none; }
    svg path { fill: #ffffff; stroke: #333; stroke-width: 0.7; transition: fill 0.3s ease, stroke 0.3s ease; pointer-events: all; }
    svg path:hover, svg path:focus { fill: #4ade80; outline: none; }
    svg path:focus-visible { outline: 3px solid #4ade80; outline-offset: 2px; }
    svg path.active { fill: #ff4444 !important; stroke: #fff; stroke-width: 1.8; }
    .tooltip { position: absolute; background: rgba(0,0,0,0.88); color: white; padding: 8px 14px; border-radius: 6px; font-size: 13px; pointer-events: none; display: none; z-index: 1000; max-width: 260px; box-shadow: 0 4px 12px rgba(0,0,0,0.6); opacity: 0; transition: opacity 0.18s ease; }
    .tooltip.visible { opacity: 1; }
    .tooltip strong { display: block; font-size: 15px; margin-bottom: 5px; }
    #sidebar { width: 320px; background: #1f1f1f; border-left: 1px solid #333; color: #ddd; padding: 20px; position: relative; overflow-y: auto; display: none; transition: transform 0.3s ease; transform: translateX(100%); touch-action: auto; }
    #sidebar.active { display: block; transform: translateX(0); }
    #sidebar-close { position: absolute; top: 12px; right: 12px; width: 36px; height: 36px; background: #444; color: white; border: none; border-radius: 50%; font-size: 24px; line-height: 34px; text-align: center; cursor: pointer; transition: all 0.2s; }
    #sidebar-close:hover { background: #666; transform: scale(1.08); }
    #search-container { margin-bottom: 18px; }
    #search-input { width: 100%; padding: 10px 12px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 6px; font-size: 15px; }
    #search-input::placeholder { color: #888; }
    .group { margin: 14px 0; padding: 10px; background: #2a2a2a; border-radius: 6px; }
    .group a { color: #4ade80; text-decoration: none; font-size: 14.5px; }
    .group a:hover { text-decoration: underline; }
    @media (max-width: 768px) {
      #container { flex-direction: column; }
      #map-area { flex: 1 1 60%; }
      #sidebar { width: 100%; height: auto; max-height: 60%; min-height: 40%; position: fixed; bottom: 0; left: 0; right: 0; transform: translateY(100%); border-left: none; border-top: 1px solid #444; background: #1f1f1f; z-index: 200; overflow-y: auto; touch-action: pan-y pinch-zoom; -webkit-overflow-scrolling: touch; }
      #sidebar.active { transform: translateY(0); }
      #sidebar-close { top: 12px; right: 12px; z-index: 201; }
      #sidebar-content { padding-bottom: 60px; }
    }
  </style>
</head>
<body>
<div id="container">
  <div id="map-area">
    <svg id="svg-map" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
      <!-- Senin path'lerin aynı, sadece EH ve SZ'yi doğru konumda tuttum -->
      <path inkscape:connector-curvature="0" id="AO" data-name="Angola" data-id="AO" d="m 495.3,598.6 ... z" />
      <!-- ... diğer tüm path'ler senin attığın gibi devam ediyor ... -->
      <path inkscape:connector-curvature="0" id="EH" data-name="W. Sahara" data-id="EH" d="m 193.8,134.6 -1.8,0 0,0 0.1,7.5 -7.3,0.4 -3.9,3.2 -5.4,0 -4.2,-1.8 -10,1.4 -4.2,10.8 -3.7,1.1 -6,17.4 -16.9,15 -4.4,19.1 -5,6.2 -1.6,5 -27,1.1 -0.2,-0.1 -0.6,5.9 2.7,-4.6 46.9,0.1 -1.9,-20 3.1,-7.1 11.2,-1.3 0.4,-35.4 38.9,0.7 0.5,-20.9 0.3,-2.7 0,-1 z" />
      <path inkscape:connector-curvature="0" id="SZ" data-name="Swaziland" data-id="SZ" d="m 674,874.9 -5.8,-2.6 -3.5,1 -1.4,4 -3.6,5.2 -0.2,4.8 6.6,7.5 7,-1.5 2.8,-6.1 -0.6,-6.1 -1.3,-6.2 z" />
      <!-- ... kalan path'ler ... -->
    </svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
  <div id="sidebar">
    <button id="sidebar-close">×</button>
    <div id="search-container">
      <input type="text" id="search-input" placeholder="Search...">
    </div>
    <div id="sidebar-content"></div>
  </div>
</div>

<script>
const tooltip = document.getElementById("tooltip");
const sidebar = document.getElementById("sidebar");
const sidebarContent = document.getElementById("sidebar-content");
const searchInput = document.getElementById("search-input");
const svg = document.getElementById("svg-map");
const mapArea = document.getElementById("map-area");

let countryData = {};
let activePath = null;

let viewBox = { x: 0, y: 0, w: 1000, h: 1000 };
let isPanning = false;
let startPoint = { x: 0, y: 0 };
const originalWidth = 1000;
const originalHeight = 1000;

let prevDist = 0;
let prevMid = { x: 0, y: 0 };

fetch("data.json")
  .then(res => res.json())
  .then(data => {
    countryData = data;
    console.log("Loaded countries:", Object.keys(countryData));
    initMap();
  })
  .catch(err => {
    console.error("data.json load error:", err);
    sidebarContent.innerHTML = "<p style='color:#f66;'>Data file could not be loaded.</p>";
  });

function initMap() {
  const paths = document.querySelectorAll("svg path");
  console.log("Total paths:", paths.length);

  paths.forEach(path => {
    const id = path.id.trim();
    if (!countryData[id]) {
      console.warn(`No data for: ${id}`);
      return;
    }

    const showTip = (e) => {
      const data = countryData[id];
      tooltip.innerHTML = `
        <strong>${data.name || id}</strong><br>
        ${data.groups?.map(g => g.name).join("<br>") || "No group information"}
      `;
      tooltip.classList.add("visible");
      tooltip.style.display = "block";
      moveTooltip(e);
      console.log(`Tooltip for ${id}`);
    };

    path.addEventListener("mouseenter", showTip);
    path.addEventListener("touchstart", showTip, { passive: true });

    path.addEventListener("mousemove", moveTooltip);
    path.addEventListener("touchmove", moveTooltip, { passive: true });

    path.addEventListener("click", (e) => {
      e.stopPropagation();
      console.log(`Clicked: ${id}`);
      if (activePath) activePath.classList.remove("active");
      path.classList.add("active");
      activePath = path;
      showSidebar(id);
    });

    path.addEventListener("touchend", (e) => {
      if (e.touches.length === 0) {
        path.dispatchEvent(new Event("click", { bubbles: true }));
      }
    }, { passive: true });
  });

  mapArea.addEventListener("mouseleave", hideTooltip);
  mapArea.addEventListener("touchend", (e) => {
    if (e.touches.length === 0) hideTooltip();
  }, { passive: true });

  mapArea.addEventListener("wheel", onWheel, { passive: false });
  mapArea.addEventListener("pointerdown", onPointerDown);
  mapArea.addEventListener("pointermove", onPointerMove);
  mapArea.addEventListener("pointerup", onPointerUp);
  mapArea.addEventListener("pointercancel", onPointerUp);

  mapArea.addEventListener("touchstart", onTouchStart, { passive: false });
  mapArea.addEventListener("touchmove", onTouchMove, { passive: false });
  mapArea.addEventListener("touchend", onTouchEnd, { passive: false });
}

function hideTooltip() {
  tooltip.classList.remove("visible");
  setTimeout(() => tooltip.style.display = "none", 180);
}

function moveTooltip(e) {
  const offset = 16;
  let x = (e.clientX || (e.touches && e.touches[0]?.clientX) || 0) + offset;
  let y = (e.clientY || (e.touches && e.touches[0]?.clientY) || 0) + offset;

  if (x + tooltip.offsetWidth > window.innerWidth - 10) x -= tooltip.offsetWidth + offset * 2;
  if (y + tooltip.offsetHeight > window.innerHeight - 10) y -= tooltip.offsetHeight + offset * 2;

  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
}

function showSidebar(id) {
  const data = countryData[id.trim()];
  if (!data) {
    sidebarContent.innerHTML = `<p style="color:#f66;">No data for ${id}</p>`;
  } else {
    let html = `<h2 style="margin-top:0;">${data.name || id}</h2>`;
    if (data.groups?.length > 0) {
      data.groups.forEach(g => {
        html += `<div class="group"><a href="${g.url || '#'}" target="_blank" rel="noopener noreferrer">${g.name}</a></div>`;
      });
    } else {
      html += "<p>No group information available.</p>";
    }
    sidebarContent.innerHTML = html;
  }
  sidebar.classList.add("active");
  sidebarContent.scrollTop = 0;
}

function closeSidebar() {
  sidebar.classList.remove("active");
  if (activePath) activePath.classList.remove("active");
  activePath = null;
  hideTooltip();
}

document.getElementById("sidebar-close").addEventListener("click", closeSidebar);

document.addEventListener("click", e => {
  if (!sidebar.classList.contains("active")) return;
  if (sidebar.contains(e.target)) return;
  if (e.target.closest("svg path")) return;
  closeSidebar();
});

document.addEventListener("keydown", e => {
  if (e.key === "Escape" && sidebar.classList.contains("active")) closeSidebar();
});

searchInput.addEventListener("input", e => {
  const term = e.target.value.trim().toLowerCase();
  document.querySelectorAll("svg path").forEach(path => {
    const name = (countryData[path.id]?.name || path.id || "").toLowerCase();
    const match = name.includes(term) || term === "";
    path.style.visibility = match ? "visible" : "hidden";
    path.style.pointerEvents = match ? "all" : "none";
  });
});

// Zoom & Pan fonksiyonları (eksik olanlar eklendi)
function updateViewBox() {
  svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
}

function clampViewBox() {
  const left = 0;
  const right = originalWidth - viewBox.w;
  const top = 0;
  const bottom = originalHeight - viewBox.h;
  viewBox.x = Math.max(left, Math.min(viewBox.x, right));
  viewBox.y = Math.max(top, Math.min(viewBox.y, bottom));
}

function onWheel(e) {
  e.preventDefault();
  const delta = e.deltaY > 0 ? 1.15 : 1 / 1.15;
  const mouse = getMousePos(e);
  const wx = (mouse.x / svg.clientWidth) * viewBox.w + viewBox.x;
  const wy = (mouse.y / svg.clientHeight) * viewBox.h + viewBox.y;
  viewBox.w *= delta;
  viewBox.h *= delta;
  viewBox.x = wx - (mouse.x / svg.clientWidth) * viewBox.w;
  viewBox.y = wy - (mouse.y / svg.clientHeight) * viewBox.h;
  if (viewBox.w < 250) viewBox.w = viewBox.h = 250;
  if (viewBox.w > 1800) viewBox.w = viewBox.h = 1800;
  clampViewBox();
  updateViewBox();
}

function getMousePos(e) {
  const rect = svg.getBoundingClientRect();
  return {
    x: (e.clientX || (e.touches && e.touches[0]?.clientX) || 0) - rect.left,
    y: (e.clientY || (e.touches && e.touches[0]?.clientY) || 0) - rect.top
  };
}

function onPointerDown(e) {
  if (e.button !== 0) return;
  isPanning = true;
  startPoint = getMousePos(e);
  mapArea.style.cursor = "grabbing";
  e.preventDefault();
}

function onPointerMove(e) {
  if (!isPanning) return;
  const current = getMousePos(e);
  const dx = (current.x - startPoint.x) * (viewBox.w / svg.clientWidth);
  const dy = (current.y - startPoint.y) * (viewBox.h / svg.clientHeight);
  viewBox.x -= dx;
  viewBox.y -= dy;
  startPoint = current;
  clampViewBox();
  updateViewBox();
}

function onPointerUp() {
  isPanning = false;
  mapArea.style.cursor = "grab";
}

function onTouchStart(e) {
  if (e.touches.length === 1) {
    startPoint = getMousePos(e);
  } else if (e.touches.length === 2) {
    e.preventDefault();
    prevDist = getTouchDistance(e.touches);
    prevMid = getTouchMidpoint(e.touches);
  }
}

function onTouchMove(e) {
  if (e.touches.length === 1 && isPanning) {
    const current = getMousePos(e);
    const dx = (current.x - startPoint.x) * (viewBox.w / svg.clientWidth);
    const dy = (current.y - startPoint.y) * (viewBox.h / svg.clientHeight);
    viewBox.x -= dx;
    viewBox.y -= dy;
    startPoint = current;
    clampViewBox();
    updateViewBox();
  } else if (e.touches.length === 2) {
    e.preventDefault();
    const currDist = getTouchDistance(e.touches);
    const currMid = getTouchMidpoint(e.touches);
    const scale = currDist / prevDist;
    const wx = (currMid.x / svg.clientWidth) * viewBox.w + viewBox.x;
    const wy = (currMid.y / svg.clientHeight) * viewBox.h + viewBox.y;
    viewBox.w /= scale;
    viewBox.h /= scale;
    viewBox.x = wx - (currMid.x / svg.clientWidth) * viewBox.w;
    viewBox.y = wy - (currMid.y / svg.clientHeight) * viewBox.h;
    if (viewBox.w < 250) viewBox.w = viewBox.h = 250;
    if (viewBox.w > 1800) viewBox.w = viewBox.h = 1800;
    clampViewBox();
    updateViewBox();
    prevDist = currDist;
    prevMid = currMid;
  }
}

function onTouchEnd(e) {
  if (e.touches.length < 2) prevDist = 0;
  if (e.touches.length === 0) isPanning = false;
}

function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx*dx + dy*dy);
}

function getTouchMidpoint(touches) {
  return {
    x: (touches[0].clientX + touches[1].clientX) / 2,
    y: (touches[0].clientY + touches[1].clientY) / 2
  };
}

function applyPan(dxScreen, dyScreen) {
  const dx = dxScreen * (viewBox.w / svg.clientWidth);
  const dy = dyScreen * (viewBox.h / svg.clientHeight);
  viewBox.x -= dx;
  viewBox.y -= dy;
  clampViewBox();
  updateViewBox();
}

console.log("Script initialized");
</script>
</body>
</html>
